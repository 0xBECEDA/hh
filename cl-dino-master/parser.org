#+STARTUP: showall indent hidestars

* Введение

Цель данной программы - распарсить сайт. Делать мы это будем, опираясь на
считывание текста с картинки.

** Libs

Нам понадобятся разнообразные библиотеки.

#+NAME: libs
#+BEGIN_SRC lisp :noweb yes
  (eval-when (:compile-toplevel :load-toplevel :execute)
    #-clx
    (ql:quickload 'clx)
    #-zpng
    (ql:quickload 'zpng)
    #-cffi
    (ql:quickload 'cffi)
    (ql:quickload "png-read")
    (ql:quickload :bt-semaphore)
    (ql:quickload :thread-pool))

  (defpackage #:cl-autogui
    (:use #:common-lisp #:xlib)
    (:export #:x-position
             #:x-size
             #:x-position
             #:x-move
             #:x-mouse-down
             #:x-mouse-up
             #:x-click
             #:x-dbclick
             #:x-vscroll
             #:x-hscroll
             #:x-scroll
             #:x-key-down
             #:x-key-up
             #:x-press
             #:x-snapshot
             #:x-snapsearch
             #:x-get-color
             #:x-find-color))
#+END_SRC

** Display Macros

Нам нужны макросы, которые оборачивают работу с XLIB. Они используются
для того чтобы делать скриншоты и управлять клавиатурой.

#+NAME: display_macro
#+BEGIN_SRC lisp
  (in-package #:cl-autogui)

  (defmacro with-display (host (display screen root-window) &body body)
    `(let* ((,display (xlib:open-display ,host))
            (,screen (first (xlib:display-roots ,display)))
            (,root-window (xlib:screen-root ,screen)))
       (unwind-protect (progn ,@body)
         (xlib:close-display ,display))))

  (defmacro with-default-display ((display &key (force nil)) &body body)
    `(let ((,display (open-default-display)))
       (unwind-protect
            (unwind-protect
                 ,@body
              (when ,force
                (display-force-output ,display)))
         (close-display ,display))))

  (defmacro with-default-display-force ((display) &body body)
    `(with-default-display (,display :force t) ,@body))

  (defmacro with-default-screen ((screen) &body body)
    (let ((display (gensym)))
      `(with-default-display (,display)
         (let ((,screen (display-default-screen ,display)))
           ,@body))))

  (defmacro with-default-window ((window) &body body)
    (let ((screen (gensym)))
      `(with-default-screen (,screen)
         (let ((,window (screen-root ,screen)))
           ,@body))))

  (defun x-size ()
    (with-default-screen (s)
      (values
       (screen-width s)
       (screen-height s))))
#+END_SRC

** Defparams

Так же нам понадобятся некоторые глобальные переменные, например,
keysym-ы, размеры экрана, размеры скрина и т.д.

#+NAME: defparams
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  <<display_macro>>

  (defparameter *langs* "rus+eng")
  (defparameter *default-width*  (multiple-value-bind (x y) (x-size) x))
  (defparameter *default-height* (multiple-value-bind (x y) (x-size) y))
  (defparameter *teaser-width* 690)
  (defparameter *snap-x* 100)
  (defparameter *snap-y* 100)
  (defparameter *snap-width* (- *default-width* *snap-x*))
  (defparameter *snap-height* (- *default-height* *snap-y*))
  (defparameter *default-x* 60)
  (defparameter *default-y* 37)
  (defparameter *mouse-left* 1)
  (defparameter *mouse-middle* 2)
  (defparameter *hh-teaser-url*
    "https://hh.ru/search/vacancy?L_is_autosearch~false&area=2&clusters=true&enable_snippets=true&items_on_page=100&only_with_salary=true&salary=165000&specialization=1.221&page~~A"
    "https://spb.hh.ru/search/vacancy?L_is_autosearch~false&area=1&clusters=true&enable_snippets=true&items_on_page=100&only_with_salary=true&salary=165000&specialization=1.221&page~~A")

  (defparameter *browser-path*  "/usr/bin/firefox")
#+END_SRC

* Модель producer-consumers

Итак, мы хотим, реализовать систему, в которой один поток-поставщик
(~producer~) скриншотит экран, проматывает его вниз, скриншотит вновь, а
потом формирует задачу (~task~) для нескольких потоков-потребителей
(~consumers~), которые эту задачу будут обрабатывать.

Таким образом поток-поставщик и потоки-потребители взаимодействуют только
через очередь задач (~task-queue~), доступ к которой защищен блокировкой
(~lock~). У нас также есть очередь результатов - в нее потоки потребители
помещают результаты обработки задач.

#+NAME: queues
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  (defparameter *task-queue* nil)
  (defparameter *results-queue* nil)
#+END_SRC

Оформим отладочный вывод, как отдельные операции:

#+NAME: dbg_queue
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  (defmacro dbg (msg &rest params)
    `(bt:with-lock-held (*outlock*)
       (format t ,msg ,@params)
       (finish-output)))

  (defmacro dbg-task-queue ()
    `(bt:with-lock-held
      (*task-queue-lock*)
      (dbg "~%:: debug task queue: ~A"
           (mapcar #'(lambda (task)
                       (cons (task-image-up-path task)
                             (task-image-down-path task)))
                   ,*task-queue*))))
#+END_SRC

Поток-поставщик уведомляет об обновлении очереди через механизм
~condition-variable~ реализованный в библиотеке потоков BORDEAUX-THREADS
поверх библиотеки SB-THREAD, которая специфична для sbcl. В свою очередь
SB-THREAD реализует этот механизм опираясь на "POSIX condition variable".

Поток-потребитель обращается к ~condition-variable~ и в этот момент
операционная система останавливает его, пока эта переменная не станет
TRUE. Когда это произойдет поток продолжит исполнение. Этот механизм
позволяет не тратить ресурсы в цикле ожидания.

Нам нужны следующие ~condition-variables~:

#+NAME: condition_variables
#+BEGIN_SRC lisp
  (in-package #:cl-autogui)

  (defparameter *cv-pc*    (bt:make-condition-variable :name "cv-pc"))
  (defparameter *cv-roll*  (bt:make-condition-variable :name "cv-roll"))
#+END_SRC

Создадим процедуру, которая запускает один поток-поставщик, несколько
потоков-потребителей и поток-склейку.

Поток-поставщик и потоки-потребители разделяют две блокировки:
~task-queue-lock~ для очереди (на ней выполняется ожидание) и ~outlock~ -
для вывода сообщений в стандартный вывод.

[COMMENT:gmm] Тут как-то еще используется ~results-queue-lock~. Надо
подробно описать как.

#+NAME: thread_locks
#+BEGIN_SRC lisp
  (in-package #:cl-autogui)

  (defparameter *task-queue-lock*     (bt:make-lock "task-queue-lock"))
  (defparameter *outlock*             (bt:make-lock "output-lock"))
  (defparameter *results-queue-lock*  (bt:make-lock "results-queue-lock"))
#+END_SRC

Процедура ниже создает потоки
- поток-поставщик
- потоки-потребители
- поток, который склеивает рулон

Она возвращает список потоков-потребителей

#+NAME: pc_create_threads
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<queues>>
  <<dbg_queue>>
  <<thread_locks>>
  <<condition_variables>>
  <<pc_producer>>
  <<pc_consumer>>

  (defun create-threads (num-of-cores)
    (dbg "~%thread 'producer' created")
    (bt:make-thread
     (lambda ()
       (producer))
     :name "producer")
    ;; Временно выключил, чтобы сократить поверхность отладки
    ;; (bt:make-thread (lambda ()
    ;;                   (create-roll "~/Pictures/roll.png"
    ;;                                cv-roll
    ;;                                results-queue-lock))
    ;;                 :name "roll-thread"
    ;;                 :initial-bindings
    ;;                 `((*standard-output* . ,*standard-output*)))
    ;; (dbg "~%thread 'producer-thread' created")
    (loop :for th-idx :from 0 :to (- num-of-cores 1) :collect
         (progn
           (dbg "~%thread 'consumer-~A' created" th-idx)
           (bt:make-thread
            (lambda ()
              (consumer))
            :name (format nil "consumer-~A" th-idx)
            :initial-bindings
            `((*standard-output* . ,*standard-output*))))))
#+END_SRC

** Producer thread function

Теперь определим функцию потока-поставщика, которая должна формировать
~task~. Так как он формируется из предыдущего и следующего изображения,
то мы можем хранить предыдущее в переменной в замыкании, чтобы не
скриншотить его повторно. Эта переменная хранит пару из имени
сохраненного файла и изображения.

#+NAME: pc_producer
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<pc_producer_aux>>

  (let ((prev-img))
    (defun producer ()
      (dbg "~%~A started" (bt:thread-name (bt:current-thread)))
      (loop
         ;; Если предыдущего изображения нет - сделаем его
         (unless prev-img
           (dbg "~%~A make first screenshot"
                (bt:thread-name (bt:current-thread)))
           (setf prev-img (save-screenshot (take-screenshot))))
         ;; Прокрутим экран вниз
         (pgdn)
         (dbg "~%~A page down"
              (bt:thread-name (bt:current-thread)))
         ;; Сделаем следующее изображение
         (let ((next-img (save-screenshot (take-screenshot))))
           (dbg "~%~A make next screenshot"
                (bt:thread-name (bt:current-thread)))
           ;; Сформируем новый таск
           (destructuring-bind (height-down width-down)
               (array-dimensions (cdr next-img))
             (declare (ignore width-down))
             (let ((new-task (make-task :y-points (loop
                                                     :for pnt
                                                     :from height-down
                                                     :downto 0
                                                     :collect pnt)
                                        :image-up (cdr prev-img)
                                        :image-down (cdr next-img)
                                        :image-up-path (car prev-img)
                                        :image-down-path (car next-img)
                                        :fn #'analize-img-pair)))
               ;; Запишем его в очередь
               (bt:with-lock-held (*task-queue-lock*)
                  (setf *task-queue*
                        (append *task-queue*
                                (list new-task))))
               (dbg "~%~A make task in taskqueue"
                    (bt:thread-name (bt:current-thread)))
               (dbg-task-queue)
               ;; Сделаем последнее изображение новым предыдущим
               (setf prev-img next-img)
               ;; Уведомим потребителей об обновлении очереди задач
               (bt:condition-notify *cv-pc*)
               (dbg "~%~A notyfyed"
                    (bt:thread-name (bt:current-thread)))
               )))
         ;; Теперь можно поспать, чтобы не быть слишком быстрым
         (sleep 1))))
#+END_SRC

*** Producer thread auxiliary functions

Чтобы функция потока-поставщика могла:
- делать и сохранять скриншоты
- прокручивать экран
ей нужны вспомогательные функции

У нас также есть вспомогательная функция ~analize-img-pair~ ссылка на
которую заносится в ~task~ но ее определение будет в блоке
вспомогательных функций потока-потребителя, потому что именно там она
исполняется.

Также для того чтобы делать скриноты и обрабатывать их нам нужны функции
- save-png
- load-png
- fake-events
- x-snapshot
- binarization

#+NAME: pc_producer_aux
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<save_png>>
  <<load_png>>

  (let ((screen-cnt 0))
    (defun save-screenshot (img)
      (let ((path (format nil "img-~A" (incf screen-cnt))))
        (cons path
              (destructuring-bind (height width)
                  (array-dimensions img)
                (save-png width height path img :grayscale)
                img)))))

  <<fake_events>>

  (defun pgdn ()
    (sleep 1)
    (perform-key-action t 117)
    (sleep 1)
    (perform-key-action nil 117)
    (sleep 1))

  <<x_snapshot>>
  <<binarization>>

  (defun take-screenshot ()
    (binarization
     (x-snapshot :x *snap-x* :y *snap-y*
                 :width *snap-width* :height *snap-height*)))

  <<the_task>>
#+END_SRC

**** Save PNG


Эта функция сохранит переданный массив пикселей как изображение. Для
этого ей нужны размеры скрина и путь, по кторому следует картинку
сохранить.

#+NAME: save_png
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun save-png (width height pathname-str image
                   &optional (color-type :truecolor-alpha))
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type color-type))
           (vector (make-array ;; displaced vector - need copy for save
                    (* height width (zpng:samples-per-pixel png))
                    :displaced-to image :element-type '(unsigned-byte 8))))
      ;; Тут применен потенциально опасный трюк, когда мы создаем
      ;; объект PNG без данных, а потом добавляем в него данные,
      ;; используя неэкспортируемый writer.
      ;; Это нужно чтобы получить третью размерность массива,
      ;; который мы хотим передать как данные и при этом
      ;; избежать создания для этого временного объекта
      (setf (zpng::%image-data png) (copy-seq vector))
      (zpng:write-png png pathname-str)))
#+END_SRC

**** Load PNG

~Load-png~ принимает путь к файлу, а возвращает его массив типа
~zpng:data-array~.

#+NAME: load_png
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun load-png (pathname-str)
    "Возвращает массив size-X столбцов по size-Y точек,
     где столбцы идут слева-направо, а точки в них - сверху-вниз
     ----
     В zpng есть указание на возможные варианты COLOR:
     ----
           (defmethod samples-per-pixel (png)
             (ecase (color-type png)
               (:grayscale 1)
               (:truecolor 3)
               (:indexed-color 1)
               (:grayscale-alpha 2)
               (:truecolor-alpha 4)))
    "
    (let* ((png (png-read:read-png-file pathname-str))
           (image-data (png-read:image-data png))
           (color (png-read:colour-type png))
           (dims (cond ((or (equal color :truecolor-alpha)
                            (equal color :truecolor))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)
                              (array-dimension image-data 2)))
                       ((or (equal color :grayscale)
                            (equal color :greyscale))
                        (list (array-dimension image-data 1)
                              (array-dimension image-data 0)))
                       (t (error 'unk-png-color-type :color color))))
           (result ;; меняем размерности X и Y местами
            (make-array dims :element-type '(unsigned-byte 8))))
      ;; (dbg "~% new-arr ~A "(array-dimensions result))
      ;; ширина, высота, цвет => высота, ширина, цвет
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension result 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension result 1)))
                        ,@body))))
        (cond ((or (equal color :truecolor-alpha)
                   (equal color :truecolor))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension result 2)))
                        (setf (aref result y x z)
                              (aref image-data x y z)))))
              ((or (equal color :grayscale)
                   (equal color :greyscale))
               (cycle (setf (aref result y x)
                            (aref image-data x y))))
              (t (error 'unk-png-color-type :color color)))
        result)))
#+END_SRC




**** Fake Events
:PROPERTIES:
:xtest: xlib/xtest
:END:

NB: По какой-то странной причине (предположительно - разные версии
библиотеки-враппера ~xlib~) тут есть проблема с вызовом функций из пакета
~xtest=. В одной конфигурации пакет должен быть обьявлен как =xtest~, а в
другой - как ~xlib/xtest~. Чтобы нивелировать подобные различия я
использовал механизм ~properties=, объявив property =xtest~ и обращаясь к
нему когда мы танглим исходный код в файл. Теперь будет достаточно
изменить это в одном месте и перегенерировать код.

#+NAME: get_property
#+BEGIN_SRC elisp :var prop=""
  (org-entry-get nil prop t)
#+END_SRC

Итак, мы невероятные молодцы, научились делать скрин и взаимодейстсовть с ним. Но чтоб
парсить сайт, надо странички скролить, на ссылочки нажимать и вообще симулировать
бурную деятельность.

В этом нам помогут следующие вспомогательные функции.

#+NAME: fake_events
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun x-move (x y)
    (if (and (integerp x) (integerp y))
        (with-default-display-force (d)
          (<<get_property("xtest")>>:fake-motion-event d x y))
        (error "Integer only for position, (x: ~S, y: ~S)" x y)))

  (defun mklist (obj)
    (if (and
         (listp obj)
         (not (null obj)))
        obj (list obj)))

  (defmacro defun-with-actions (name params actions &body body)
    ;; "This macro defun a function which witch do mouse or keyboard actions,
    ;; body is called on each action."
    `(defun ,name ,params
       (mapcar
        #'(lambda (action)
            ,@body)
        (mklist ,actions))))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name
                    (&key (button 1) x y)
                    ,actions
                  (funcall #'perform-mouse-action
                           action button :x x :y y))))
    (def x-mouse-down t)
    (def x-mouse-up nil)
    (def x-click '(t nil))
    (def x-dbclick '(t nil t nil)))

  (defmacro with-scroll (pos neg clicks x y)
    `(let ((button (cond
                     ((= 0 ,clicks) nil)
                     ((> 0 ,clicks) ,pos)    ; scroll up/right
                     ((< 0 ,clicks) ,neg)))) ; scroll down/left
       (dotimes (_ (abs ,clicks))
         (x-click :button button :x ,x :y ,y))))

  (defun x-vscroll (clicks &key x y)
    (with-scroll 4 5 clicks x y))

  (defun x-scroll (clicks &key x y)
    (x-vscroll clicks :x x :y y))

  (defun x-hscroll (clicks &key x y)
    (with-scroll 7 6 clicks x y))

  (macrolet ((def (name actions)
               `(defun-with-actions ,name (keycode)
                    ,actions
                  (funcall #'perform-key-action
                           action keycode))))
    (def x-key-down t)
    (def x-key-up nil)
    (def x-press '(t nil)))

  <<mouse-and-key-actions>>
#+END_SRC

Глядя на все это многообразие можно ужаснуться, но напрямую мы будем взаимодейстсовать
только с этими двумя функциями.

~perform-mouse-action~ создает фейковое событие мышки, а ~perform-key-action~ создает
фейковое событие клаиватуры. Обе функции принимают первым параметров t или nil, что
соответствует "нажать" и "отпустить" в переводе на человеческий, затем
~keysym~. ~perform-mouse-action~ принимает еще и координаты, куда следует кликнуть
"мышкой".

#+NAME: mouse-and-key-actions
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun perform-mouse-action (press? button &key x y)
    (and x y (x-move x y))
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-button-event d button press?)))

  (defun perform-key-action (press? keycode) ; use xev to get keycode
    (with-default-display-force (d)
      (<<get_property("xtest")>>:fake-key-event d keycode press?)))

  ;; (block perform-key-action-test
  ;;   (perform-key-action t 116)
  ;;   (sleep .1)
  ;;   (perform-key-action nil 116))

  ;; (block perform-mouse-action-test
  ;;   (perform-mouse-action t *mouse-left* :x 100 :y 100)
  ;;   (sleep .1)
  ;;   (perform-mouse-action nil *mouse-left* :x 100 :y 100))
#+END_SRC

**** X-Snapshot

Функция, которая делает скриншот.

Она принимает следующие key-параметры:
- ~X~ и ~Y~ координаты начала области снапошота
- Размер по высоте и ширене в пискселях (по умолчанию размеры окна)
- необязательный путь, по которму следует сохранить.

Возвращает массив RGB, т.е. массив с пикселями текущего скрина типа
~zpng:data-array~.

При обращении к какому-то его элементу, следуюет сначала указывать ~Y~, а
потом ~X~. Например (aref image-data y x 1).

#+NAME: x_snapshot
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  <<raw_image_png>>

  (defun x-snapshot (&key (x *default-x*) (y *default-y*)
                       (width *default-width*) (height *default-height*)
                       path)
    ;; "Return RGB data array (The dimensions correspond to the height, width,
    ;; and pixel components, see comments in x-snapsearch for more details),
    ;; or write to file (PNG only), depend on if you provide the path keyword"
    (with-default-window (w)
      (let ((image
             (raw-image->png
              (xlib:get-raw-image w :x x :y y
                                  :width width :height height
                                  :format :z-pixmap)
              width height)))
        (if path
            (let* ((ext (pathname-type path))
                   (path
                    (if ext
                        path
                        (concatenate 'string path ".png")))
                   (png? (or (null ext) (equal ext "png"))))
              (cond
                (png? (zpng:write-png image path))
                (t (error "Only PNG file is supported"))))
            (zpng:data-array image)))))

  ;; (block save-load-binarixation-test
  ;;   (x-snapshot :x *snap-height*
  ;;               :width  *snap-width*
  ;;               :path "~/Pictures/snapshot-test.png"))
#+END_SRC

Внимательный читатель заметил, что x-snapshot вызывает raw-image->png. Зачем? Дело в
том, что изначально массив пикселей организован по принципу BRG и чтоб получить
привычный нам формат RGB, необходимо массив подкорректировать. Это и делает ~raw-image->png~.

#+NAME: raw_image_png
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun raw-image->png (data width height)
    (let* ((png (make-instance 'zpng:png :width width :height height
                               :color-type :truecolor-alpha
                               :image-data data))
           (data (zpng:data-array png)))
      (dotimes (y height)
        (dotimes (x width)
          ;; BGR -> RGB, ref code: https://goo.gl/slubfW
          ;; diffs between RGB and BGR: https://goo.gl/si1Ft5
          (rotatef (aref data y x 0) (aref data y x 2))
          (setf (aref data y x 3) 255)))
      png))
#+END_SRC

**** Binarization

Бинаризация изображения. Зачем? Во-первых, анализировать бинарное
изображение проще и быстрее, во-вторых, его лучше распознает нейросеть.

Функция принимает массив изображения и порог, который укажет, что считать
белым, а что - черным. Например, если вы укажете порог 127, то все, что
будет иметь цвет пикселя выше 127, будет считаться белым.

Возвращает бинаризованный массив.

#+NAME: binarization
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  <<condition>>

  (defun binarization (image &optional threshold)
    (let* ((dims (array-dimensions image))
           (new-dims (cond ((equal 3 (length dims))  (butlast dims))
                           ((equal 2 (length dims))  dims)
                           (t (error 'binarization-error))))
           (result (make-array new-dims :element-type '(unsigned-byte 8))))
      (macrolet ((cycle (&body body)
                   `(do ((y 0 (incf y)))
                        ((= y (array-dimension image 0)))
                      (do ((x 0 (incf x)))
                          ((= x (array-dimension image 1)))
                        ,@body))))
        (cond ((equal 3 (length dims))
               (cycle (do ((z 0 (incf z)))
                          ((= z (array-dimension image 2)))
                        (let ((avg (floor (+ (aref image y x 0)
                                             (aref image y x 1)
                                             (aref image y x 2))
                                          3)))
                          (when threshold
                            (if (< threshold avg)
                                (setf avg 255)
                                (setf avg 0)))
                          (setf (aref result y x) avg)))))
              ((equal 2 (length dims))
               (cycle (let ((avg (aref image y x)))
                        (when threshold
                          (if (< threshold avg)
                              (setf avg 255)
                              (setf avg 0)))
                        (setf (aref result y x) avg))))
              (t (error 'binarization-error))))
      result))

  ;; <<save-load-binarization-test>>
#+END_SRC

Хорошо бы еще засечь ошибку, когда мы пытаемся прочитать png,
в котором неизвестно сколько байт на точку.

#+NAME: condition
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  ;; Ошибка, возникающая когда мы пытаемся прочитать png
  ;; в котором неизвестно сколько байт на точку
  (define-condition unk-png-color-type (error)
    ((color :initarg :color :reader color))
    (:report
     (lambda (condition stream)
       (format stream "Error in LOAD-PNG: unknown color type: ~A"
               (color condition)))))
#+END_SRC

Последнее, чего нам не хватает - это тесты, чтоб проверить всю эту красоту.

#+NAME: save-load-binarization-test
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (block save-load-binarixation-test
    (x-snapshot :x 440 :width  *snap-width*
                :path "~/Pictures/test.png")
    (let* ((image (load-png "~/Pictures/test.png"))
           (image (binarization image 200)))
      (destructuring-bind (dh dw)
          (array-dimensions image)
        (save-png dw dh "~/Pictures/test-bin.png"
                 image  :grayscale))))

  (block save-load-full-color-test
    (x-snapshot :x 440 :width *snap-width*
                :path "~/Pictures/test.png")
    (sleep .1)
    (let* ((image (load-png "~/Pictures/test.png")))
    (destructuring-bind (dh dw colors)
        (array-dimensions image)
      (save-png dw dh "~/Pictures/test-full-color.png" image))))
#+END_SRC

**** The Task

Структура таска содержит в себе:
- список ~y-point~-ов. Это список координат ~Y~ изображения ~image-down~,
  который нужен, чтоб накладывать ~image-down~ на ~image-up~ построчно,
  пока изображения ~image-down~ или ~image-up~ не кончатся. В случае
  вопросов по механизму наложения см ~xor-area~
- image-up - массив изображения image-up
- image-down - массив изображения image-down
- image-up-path - путь к изображению image-up
- image-down-path - путь к изображению image-down
- fn - лябда-функция,которая будет исполнять таск

#+NAME: the_task
#+BEGIN_SRC lisp :noweb yes
  (defstruct task
    (y-points '())
    (image-up nil)
    (image-down nil)
    (image-up-path nil)
    (image-down-path nil)
    fn)
#+END_SRC

** Consumer thread function

Теперь определим функцию потоков-потребителей. Ее задача - ожидать на
переменной ~task-queue-lock~, забирать ~task~, выполнять его, находить
лучший результат, отправлять его в очередь результатов ~results-queue~. В
случае уведомления от ~find-best~ о нахождении последней картинки,
функция должна запустить процесс уничтожения всех побочных потоков, кроме
потока-склейки

Если тасков нет (такое может случиться в самом начале сессии обработки) -
мы просто пропускаем шаг.

Также мы будем принудительно завершать поток-поставщик и все
потоки-потребители в следующих случаях:
- Если поток обработал достаточное кол-во тасков
- Если очередь содержит слишком много тасков (она наполняется быстрее чем
  успеваем обрабатывать)

#+NAME: pc_consumer
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<pc_consumer_aux>>

  (defun consumer ()
    (unless (bt:thread-alive-p (find-thread-by-name "producer"))
      (bt:destroy-thread (bt:current-thread)))
    (dbg "~%~A started" (bt:thread-name (bt:current-thread)))
    (loop (let ((cur-task))
            ;; pop task to cur-task
            (bt:with-lock-held (*task-queue-lock*)
              (bt:condition-wait *cv-pc* *task-queue-lock*)
              (setf cur-task (pop *task-queue*)))
            (if (null cur-task)
                ;; if no task then skip step
                (dbg "~%~A reported: no task in queue; skip"
                     (bt:thread-name (bt:current-thread)))
                ;; else
                (progn
                  (dbg "~%~A woke up for ~A; ~A tasks left"
                       (bt:thread-name (bt:current-thread))
                       (cons (task-image-up-path cur-task)
                             (task-image-down-path cur-task))
                       (length *task-queue*))
                  ;; analize task and push best results to the queue
                  ;; (let* ((cur-results (funcall (task-fn cur-task)
                  ;;                              (task-image-up cur-task)
                  ;;                              (task-image-down cur-task)
                  ;;                              (task-y-points cur-task))))
                  ;;   ;; find best results after analize
                  ;;   (multiple-value-bind (best-res last?)
                  ;;       (find-best cur-results)
                  ;;     (let ((new-result (make-result
                  ;;                        :white (cdr (car best-res))
                  ;;                        :black (car (car best-res))
                  ;;                        :y-point (cdr best-res)
                  ;;                        :image-up (task-image-up cur-task)
                  ;;                        :image-down (task-image-down cur-task))))
                  ;;       (bt:with-lock-held (task-queue-lock)
                  ;;         (setf *results-queue* (append *results-queue* (list new-result))))
                  ;;       (bt:with-lock-held (outlock)
                  ;;         (dbg " ~% thread ~A ; best-res ~A for ~A results ~A;
                  ;;                     ~A tasks left"
                  ;;                 (bt:thread-name (bt:current-thread)) best-res
                  ;;                 (cons (task-image-up-path cur-task)
                  ;;                       (task-image-down-path cur-task))
                  ;;                 (length *results-queue*) (length *task-queue*))))
                  ;;     ;; was it last image?
                  ;;     (if last?
                  ;;         ;; yes
                  ;;         ;; kill all threads
                  ;;         (progn
                  ;;           (bt:with-lock-held (outlock)
                  ;;             (dbg " ~% thread ~A: last image!"
                  ;;                     (bt:thread-name (bt:current-thread))))
                  ;;           (bt:with-lock-held (*task-queue-lock*)
                  ;;             (bt:condition-notify *cv-roll*)))
                  ;;         )))
                  )))))
#+END_SRC

*** Consumer thread auxiliary functions

Чтобы функция потока-потребителя могла:
- искать потоки по имени (~find-thread-by-name~)
- сообщать об остановке (~stop-report-and-kill-producer~)
- выполнять задачи (~analize-img-pair~)
- искать лучший результат среди результатов анализа (~find-best~)
- инициировать убийство себя и всех ~consumers~ в том числе
  по достижении конца страницы выдачи ~kill-all-consumers~
ей нужны вспомогательные функции

#+NAME: pc_consumer_aux
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<open_browser>>

  (defun find-thread-by-name (thread-name)
    (cdr (assoc thread-name
                (mapcar #'(lambda (thread)
                            (cons (bt:thread-name thread)
                                  thread))
                        (bt:all-threads))
                :test #'equal)))

  (defun stop-report-and-kill-producer (msg)
    (dbg "~% ~A reported: ~A; stop"
         (bt:thread-name (bt:current-thread))
         msg)
    (let ((producer (find-thread-by-name "producer-thread")))
      (when producer
        (bt:destroy-thread producer))))

  (defun kill-all-consumers (msg)
    (dbg "~% ~A reported: ~A; stop all threads"
         (bt:thread-name (bt:current-thread))
         msg)
    ;; KILL ALL THREADS!
    (mapcar #'(lambda (pair)
                (bt:destroy-thread (cadr pair)))
            ;; Отфильтровываем всех консюмеров
            (remove-if-not #'car
                           ;; Превращаем его в список кортежей
                           ;; Первый элемент каждого кортежа - является ли поток консюмером
                           (mapcar #'(lambda (th)
                                       (let* ((name (bt:thread-name th))
                                              (bool (equal "consum" (subseq name 0 6))))
                                         (list bool th name)))
                                   ;; Берем список потоков
                                   (bt:all-threads)))))

  <<analize_img_pair>>
  <<find_best>>
  <<the_result>>
#+END_SRC

**** Открытие броузера

Чтоб получить скрины с какого-либо сайта, надо сначала открыть сам сайт.
С помощью ~run-programm~ запускаем браузер (в нашем случае это firefox) с
заданным URL.

#+NAME: open_browser
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun open-browser (browser-path url)
    (let ((proc (sb-ext:run-program
                 `,browser-path
                 `(,url)
                 :input :stream :output :stream)))
      (if proc
          (with-open-stream (input (sb-ext:process-input proc))
            (with-open-stream (output (sb-ext:process-output proc))
              (do ((a-line (read-line output nil 'eof)
                           (read-line output nil 'eof)))
                  ((eql a-line 'eof))
                (dbg "~A" a-line)
                (force-output output))))
      (dbg "~% open-browser: didn't run firefox"))))

  ;; (block open-browser-test
  ;;  (open-browser "/usr/bin/firefox" *hh-teaser-url*))
#+END_SRC

**** Analize image pair

Для выполнения таска нам понадобится функция ~analize-img-pair~. Ссылка
на нее помещается в каждый таск при создании. Во время выполнения эта
функция вызывается с параметрами, взятыми из выполняемого таска. Это
сделано чтобы сделать механизм тасков универсальным, т.е. мы сможем
создавать иные таски, в которых будут другие выполняющиеся функции.

Алгоритм:
- С помощью операции XOR накладываем верхнюю строку пикселей ~image-down~
  на нижнюю строку пикселей ~image-up~. При этом совпадающие пиксели
  становятся черными в силу свойств XOR.
- Вычисляем количество совпавших пикселей.
- Сдвигаем ~image-down~ выше, a ~image-up~ ниже, т.е. область перекрытия
  теперь становится шире на одну строку пикселей и переходим к первому
  шагу, пока изображения не будут наложены друг на друга полностью.
- Собираем все результаты в список, где каждый подсписок представлен в
  виде ((кол-во черных пикселей . кол-во белых пикселей) . текущий
  y-point))
- возвращаем список результатов.

[COMMENT:gmm] Есть мысль что здесь еще пространство для
оптимизации. Например, можно не проходить весь путь от области перекрытия
высотой в одну строчку до области размером с высоту ~image-down~ (кстати,
почему именно ~image-down~?) а удовлетворяться раньше.

[COMMENT:gmm] Почему ты пишешь:
(setf cur-results (cons (cons amount y-point) cur-results))
Когда это полностью эквивалентно гораздо более простому:
(push (cons amount-y-point) cur-result) ?

Эта функция вызывает ~analysis~ и ~xor-area~, которые будут определены в
подразделах.

#+NAME: analize_img_pair
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  <<analysis>>
  <<xor_area>>
  <<make_bit_image>>

  (defun analize-img-pair (image-up image-down y-points)
      (print "ANALIZE-IMG-PAIR")
      (let* ((cur-results)
             (bit-image-up (make-bit-image image-up))
             (bit-image-down (make-bit-image image-down)))
        (do ((i (length y-points) (- i 1)))
            ((= i 0))
          (let ((y-point (pop y-points)))
            ;; если это первая итерация цикла
            ;; и никаких результатов еще нет
            (if (null cur-results)
                ;; анализируем изображение с текущим y-point
                ;; и допустимым кол-вом белых точек по умолчанию
                (let ((amount (analysis (xor-area bit-image-up
                                                  bit-image-down
                                                  y-point)
                                        y-point)))
                  ;; если какой-то результат получен, пушим его в cur-results
                  (when amount
                    (push (cons amount y-point) cur-results)))
                ;; если результаты были, получаем новый порог белых точек
                (let* ((last-result      (car cur-results))
                       (white       (cdr (car last-result)))
                       ;; вызываем анализ с этим порогом
                       (amount (analysis (xor-area bit-image-up
                                                   bit-image-down
                                                   y-point)
                                         y-point white)))
                  ;; если какой-то результат получен,
                  (when amount
                    ;; записываем в в текущий пулл результатов
                    (push (cons amount y-point) cur-results))))))
        cur-results))
#+END_SRC

***** Analysis

Надо проанализировать, на каком y-point наложение ксором дало макисмально "черный"
результат. Так мы выясним, где наложение дало максимальное совпадение картинок.

~Как мы будем анализировать?~

Во-первых, область наложения у нас меняется, мы ж снизу вверх двигаемся, значит, она
увеличивается. Значит, просто считать черные пиксели нельзя, ведь чем больше
изображение, тем больше там черных пикселей окажется. А, во-вторых, считать более 600
раз (или какая там у вас высота последнего скрина?) кол-во черных пикселей - это жуть
как долго.

Поэтому мы установим порог "нечерных" пикселей, выше которого подниматься нельзя. В
случае, если этот порог будет превышен, мы перестаем считать и поднимаемся выше, не
занося ничего в список результатов.

Для этого нам нужна функция analysis. Она принимает уже отксоренное изображение, точку
наложения, откуда будет производить анализ и порог белых пикселей, который по
умолчанию равен 50% от общего количества пикселей в области наложения.

Внимание! ~analysis~ пригодна ТОЛЬКО для изображений, полчуенных
с помощью ~xor-area~. Это связано с подсчетом области пересечения:
если ~xored-image~ получено с помощью ~xor-area~, то область перемечения =
всему ~xored-image~. поскльку ~xor-area~ создает новое изображение только по ксорящейся
области, не копируя остальные пиксели, как это делает ~append-xor~!

#+NAME: analysis
#+BEGIN_SRC lisp :noweb yes
    (in-package  #:cl-autogui)

    (defun analysis (xored-image y-point &optional (border 50))
      "Принимает отксоренное изображение и y-координату  наложения,
       т.е. точку, от которой будет производиться анализ.
       Анализирует кол-во почерневших точек на изображении, возвращает cons-пару типа
       (% черных точек . y-point)"
      (if (null xored-image)
          nil
          (destructuring-bind (height width &optional colors)
              (array-dimensions xored-image)
            (dbg "~% y-point ~A height ~A" y-point height)
            (let* ((intesect-height height) ;; высота пересечения
                   (white 0)
                   (black 0)
                   ;; общее кол-во пикселей в области наложения
                   (pix-amount (* intesect-height width)))
              ;; высчитываем максимально допустимое количество белых пикселей
              (setf border (* (float (/ border 100)) pix-amount))
              (dbg "~% intesect-height ~A " intesect-height)
              ;; если картинки full-color
              (if colors
                  (do ((qy y-point (incf qy)))
                      ((= qy height))
                    ;; если кол-во нечерных пикселей больше 25%
                    (if (> white border)
                        (progn
                          ;; не анализируя дальше, возвращаем nil
                          (return-from analysis))
                        ;; в противном случае анализиуем следующий ряд пикселей
                        (do ((qx 0 (incf qx)))
                            ((= qx width))
                          (when (not (and (eql (aref xored-image qy qx 0) 0)
                                          (eql (aref xored-image qy qx 1) 0)
                                          (eql (aref xored-image qy qx 2) 0)))
                            (incf white)))))
                  ;; то же самое для бинарных изображений
                  (do ((qy 0 (incf qy)))
                      ((= qy height))
                    (if (> white border)
                        (progn
                          (return-from analysis ))
                        (do ((qx 0 (incf qx)))
                            ((= qx width))
                          (when (not (eql (aref xored-image qy qx) 0))
                            (incf white))))))
              ;; эта часть выполнится только если все циклы выполнены успешно
              ;; считаем кол-во черных пикселей
              (setf black ( - pix-amount white))
              (let ((result (cons (* (float (/ black pix-amount)) 100)
                                  (* (float (/ white pix-amount)) 100))))
                ;;(dbg " ~% black ~A y-point ~A pixamount ~A" black y-point pix-amount)
                ;; возвращаем кол-во черных пикселей в процентном выражении
                result)))))

  ;; (block find-best-test
  ;;   (let* ((arr1 (make-bit-image (binarization (load-png "~/Pictures/img-2"))))
  ;;          (arr2 (make-bit-image (binarization (load-png "~/Pictures/img-3"))))
  ;;          (res)
  ;;          (amount))
  ;;     (do ((i 0 (incf i)))
  ;;         ((= i (array-dimension arr1 0)))
  ;;       (setf amount (analysis (xor-area arr1 arr2 i) i))
  ;;       (if (car amount)
  ;;           (setf res (cons (cons amount i) res))))
  ;;     (dbg "~% res ~A" res)
  ;;     (setf res (find-best res))
  ;;     (dbg "~% best-res ~A" res)
  ;;     (let ((app-arr (append-image (load-png "~/Pictures/img-2")
  ;;                                  (load-png "~/Pictures/img-3") (cdr res))))
  ;;       (destructuring-bind (height width  &rest rest)
  ;;           (array-dimensions app-arr)
  ;;         (save-png width height "~/Pictures/area.png" app-arr :grayscale)))))
#+END_SRC

***** Append Xor и Xor Area

Теперь, когда мы получили битовый массив, хорошо бы разобраться с xor-ом. Для этого
напишем две функции: ~append-xor~ и ~xor-area~.

~Append-xor~ принимает 2 массива изображений и высоту, где второе изображение будет
наложено на первое с помощью XOR. Изображения должны быть одинаковой ширины
и иметь одинаковое количество байт на пиксель. Возвращает склеенный массив.

#+NAME: append_xor
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun append-xor (image-up image-down y-point)
    (destructuring-bind (height-up width-up &optional colors-up)
        (array-dimensions image-up)
      (destructuring-bind (height-down width-down &optional colors-down)
          (array-dimensions image-down)
        (assert (equal width-up width-down))
        (assert (equal colors-up colors-down))
        (let* ((new-height (+ height-down y-point))
               (new-dims (if (null colors-down)
                             (list new-height width-down)
                             (list new-height width-down colors-down)))
               (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
          ;; макрос для прохода по блоку точек
          (macrolet ((cycle ((py px height width &optional &body newline)
                             &body body)
                       `(do ((qy ,py (incf qy)))
                            ((= qy ,height))
                          (do ((qx ,px (incf qx)))
                              ((= qx ,width))
                            ,@body)
                          ,@newline)))
            ;; копируем первую картинку в новый массив
            ;; от ее начала до ее конца (NB: тут отличие от append-image)
            (if (null colors-up)
                (cycle (0 0 height-up width-up)
                       (setf (aref image-new qy qx)
                             (aref image-up qy qx)))
                ;; else
                (cycle (0 0 height-up width-up)
                       (do ((qz 0 (incf qz)))
                           ((= qz colors-up))
                         (setf (aref image-new qy qx qz)
                               (aref image-up qy qx qz)))))
            ;; xor-им вторую картинку в новый массив
            ;; от ее начала до конца
            (if (null colors-down)
                (let ((new-y y-point))
                  (cycle (0 0 height-down width-down (incf new-y))
                         (setf (aref image-new new-y qx)
                               (logxor (aref image-new new-y qx)
                                       (aref image-down qy qx)))))
                ;; else
                (let ((new-y y-point))
                  (cycle (0 0 height-down width-down (incf new-y))
                         ;; ксорим 3 цвета
                         (do ((rz 0 (incf rz)))
                             ((= rz colors-down))
                           (setf (aref image-new new-y qx rz)
                                 (logxor (aref image-new new-y qx rz)
                                         (aref image-down qy qx rz))))
                         ;; копируем альфа-канал
                         (setf (aref image-new new-y qx 3)
                               (aref image-down qy qx 3))
                         ))))
          image-new))))

  ;; (time
  ;;  (block test-append-xor-fullcolor
  ;;    (let* ((arr1 (x-snapshot :x 0 :y 0 :width 500 :height 300))
  ;;           (arr2 (x-snapshot :x 0 :y 100 :width 500 :height 300))
  ;;           (result (append-xor arr1 arr2 200)))
  ;;      (destructuring-bind (height width  &rest rest)
  ;;          (array-dimensions result)
  ;;        (save-png width height "~/Pictures/result.png" result)))))

  ;; (block test-append-xor-grayscale
  ;;   (let* ((arr1 (binarization (x-snapshot :x 0 :y 0 :width 755 :height 300)))
  ;;          (arr2 (binarization (x-snapshot :x 0 :y 100 :width 755 :height 300)))
  ;;          (array (append-xor arr1 arr2 200)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array :grayscale))))

#+END_SRC

~xor-area~ работает почти так же, как ~append-xor~.

Так же получает на вход 2 массива изображений (изображения должны иметь
одинаковую ширину и кол-во байт на пиксель) и точку, от которой начнется
наложение.

Накладывает одно изображение на другое, но копирует только сксоренные
пиксели, т.е. исключительно область наложения одной картинки на другую.

Ограничение: ~y-point~ не должен быть больше и равен высоте ихображения,
на которое мы накладываем. Иначе мы выходим за границы массива.

Добавлено:

~xor-area~ теперь может работать с картинками любой высоты.

Высота ксорящейся области (области наложения) вычисляется следующим
образом: если (высота ~image-up~ - ~y-point~) больше, чем высота
~image-down~, мы будем считать, что область наложения = высоте
~image-down~. В противном случае нас ждет вылет за границы массива
~image-down~, если image-down короче ~image-up~.

Исправлено:
Высота нового массива = самой ксорящейся области! Поскольку ~xor-area~
сохраняет только ксорящуюся область, то используя старый метод рассчета
изображения (высота самой длинной картинки + ~y-point~), мы получаем
практически не заполненный массив: он оказывается намного длинее, чем нужно.
Это ведет к погрешностям при анализе количества черных пикселей.
#+NAME: xor_area
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)


  (defun xor-area (image-up image-down y-point)
    (destructuring-bind (height-up width-up &optional colors-up)
        (array-dimensions image-up)
      (destructuring-bind (height-down width-down &optional colors-down)
          (array-dimensions image-down)
        ;; (dbg "~% height-up ~A width-up ~A height-down ~A width-down ~A y ~A"
        ;;         height-up width-up height-down width-down y-point)
        (assert (equal width-up width-down))
        (assert (equal colors-up colors-down))
        (if (>= y-point height-up)
            nil
            (let* ((intersect-area (if (> (- height-up y-point) height-down)
                                       height-down
                                       (- height-up y-point)))
                   (new-dims (if (null colors-down)
                                 (list intersect-area width-down)
                                 (list intersect-area width-down colors-down)))
                   (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
              ;;(dbg "~% xor: intersect-area ~A" intersect-area)
              ;; макрос для прохода по блоку точек
              (macrolet ((cycle ((py px height width &optional &body newline)
                                 &body body)
                           `(do ((qy ,py (incf qy)))
                                ((= qy ,height))
                              (do ((qx ,px (incf qx)))
                                  ((= qx ,width))
                                ,@body)
                              ,@newline)))
                ;; для бинарных изображений
                (if (null colors-down)
                    (let ((new-y y-point))
                      ;; (- height-up y-point) = высота области наложения
                      (cycle (0 0 intersect-area width-down (incf new-y))
                             (setf (aref image-new qy qx)
                                   (logxor (aref image-up new-y qx)
                                           (aref image-down qy qx)))))
                    ;; для full-color изображений
                    (let ((new-y y-point))
                      (cycle (0 0 intersect-area width-down (incf new-y))
                             ;; ксорим 3 цвета
                             (do ((rz 0 (incf rz)))
                                 ((= rz (- colors-down 1)))
                               (setf (aref image-new qy qx rz)
                                     (logxor (aref image-up new-y qx rz)
                                             (aref image-down qy qx rz))))
                             ;; копируем альфа-канал
                             (setf (aref image-new qy qx 3)
                                   (aref image-down qy qx 3))))))
              image-new)))))

  ;; (block xor-area-test
  ;;   (time
  ;;   (let* ((arr1 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (arr2 (binarization (load-png "~/Pictures/test-bin.png") 200))
  ;;          (array (xor-area arr1 arr2 200)))
  ;;              (destructuring-bind (height width  &rest rest)
  ;;                 (array-dimensions array)
  ;;                (save-png width height "~/Pictures/area.png" array :grayscale)))))

  ;; (time
  ;;  (block xor-area-test-with-analysis
  ;;    (let* ((arr1  (binarization (x-snapshot :width 300 :height 600) 200))
  ;;           (arr2  (binarization (x-snapshot :y 200 :width 300 :height 200) 200))
  ;;           (arr1-bin (make-bit-image arr1))
  ;;           (arr2-bin (make-bit-image arr2))
  ;;           (amount)
  ;;           (res))
  ;;      (do ((i 0 (incf i)))
  ;;          ((= i (array-dimension arr1 0)))
  ;;        (setf amount (analysis (xor-area arr1-bin arr2-bin i) i))
  ;;        (if (car amount)
  ;;            (setf res (cons (cons amount i) res))))
  ;;      (setf res (find-best res))
  ;;      (let ((app-arr (append-image arr1 arr2 (cdr res))))
  ;;        (destructuring-bind (height width  &rest rest)
  ;;            (array-dimensions app-arr)
  ;;          (save-png width height "~/Pictures/area.png" app-arr :grayscale))))))
#+END_SRC

***** Make Bit Image

Анализировать полноцветные иображения жутко долго и энергозатратно. Поэтму мы будем
сначала их бинаризировать, а затем превращать в битовые массивы.

В этом нам поможет make-bit-image, которая принимает бинаризированный массив
изображения, а возвращает его битовый аналог.

#+NAME: make_bit_image
#+BEGIN_SRC lisp
  (in-package  #:cl-autogui)

  (defun make-bit-image (image-data)
    (destructuring-bind (height width &optional colors)
        (array-dimensions image-data)
      ;; функция может работать только с бинарными изобажениями
      (assert (null colors))
      (let* ((new-width (+ (logior width 7) 1))
             (bit-array (make-array (list height new-width)
                                    :element-type 'bit)))
        (do ((qy 0 (incf qy)))
            ((= qy height))
          (do ((qx 0 (incf qx)))
              ((= qx width))
            ;; если цвет пикселя не белый, считаем,
            ;; что это не фон и заносим в битовый массив 1
            (unless (equal (aref image-data qy qx) 255)
              (setf (bit bit-array qy qx) 1))))
        bit-array)))

  ;; (block make-bit-image
  ;;     (time
  ;;      (let* ((bit-arr1
  ;;              (make-bit-image (load-png "~/Pictures/test-bin.png"))))
  ;;        (dbg "~% ~A" bit-arr1))))
#+END_SRC

**** Find best

Чтобы найти лучший результат среди всех результатов анализа данного изображения, нам
понадобится функция ~find-best~. Она не только найдет лучший результат, но и определит,
достигли ли мы конца страницы выдачи.

Как работает ~find-best~?

Цель: найти лучший результат из списка результатов.
Лучший результат - это тот, где черных точек больше всего.

На вход она принимает все результаты анализа одного потока, сначала сортирует по
убыванию черных точек в результате (от самого выского процента до самого низкого),
затем выбирает лучший результат, который оказывается в начале.

Но у нас бывает ситуация, когда один и тот же результат полчен на разных y-point-aх.
Какой результат признать лучшим в этом случае?

Проходимся по всем результатам, имеющим одинаковый процент черных точек. Если среди них
встретился нулевой ~y-point~, значит, картинки одинаковые. Тогда лучшим признается
результат с нулевым ~y-point~, и тогда ~find-best~ возвращает вторым занчением t
Если же нулевой ~y-point~ не встретился, то текущий лучший результат
оказывается окончательным.

На выходе функция всегда должна вернуть какой-то результат.

[COMMENT:gmm] Сортировать чтобы потом взять максимальный результат -
чудовищно неоптимально. На код-ревью придется краснеть...

[COMMENT:gmm] Tagbody такого вида идеоматичнее выразить через loop, как
это сделано например в функции ~consumer~

#+NAME: find_best
#+BEGIN_SRC lisp :noweb yes
  (in-package #:cl-autogui)

  (defun find-best (thread-results)
    ;; получаем все результаты от потока
    ;; сортируем
    (let* ((sorted-result
            (sort thread-results
                  #'(lambda (a b)
                      (> (car (car a)) (car (car b))))))
           ;; берем лучший из отсортированных
           (best-res (nth 0 sorted-result))
           (i 0))
      (tagbody
       top
       ;; получаем кол-во черных точек и y-point у лучшего результата
       ;; и следующего в списке
         (let ((black-best (car (car best-res)))
               (cur-black (car (car (nth i sorted-result))))
               (cur-y (cdr (nth i sorted-result))))
           ;; если кол-во черных точек в результатах одинаковое
           (if (eql black-best cur-black)
               (progn
                 ;; берем новый результат
                 ;; это сделано, чтоб если y-point != 0,
                 ;; сохранить лучший результат с максимально низким y-point
                 ;; так можно будет склеить картинки максимально правильно,
                 ;;а не срезать половину
                 (setf best-res (nth i sorted-result))
                 ;; и при этом y-point = 0
                 (if (eql cur-y 0)
                     ;; мы нашли последнюю пару картинок
                       (return-from
                        find-best (values (nth i sorted-result) t))
                     ;; y-point != 0
                     (progn
                       ;; проверяем дальше
                       (incf i)
                       (go top))))
               ;; кол-во черных точек в результатах не одинаковое
               (return-from
                find-best best-res))))))

  ;; (block find-best-test
  ;;   (let* ((arr1 (make-bit-image (binarization (load-png "~/Pictures/img-2"))))
  ;;          (arr2 (make-bit-image (binarization (load-png "~/Pictures/img-3"))))
  ;;          (amount)
  ;;          (res))
  ;;     (do ((i 0 (incf i)))
  ;;         ((= i (array-dimension arr1 0)))
  ;;       (setf amount (analysis (xor-area arr1 arr2 i) i))
  ;;       (if (car amount)
  ;;           (setf res (cons (cons amount i) res))))
  ;;     (dbg "~% res ~A" res)
  ;;     (setf res (find-best res))
  ;;     (dbg "~% best-res ~A" res)
  ;;     (let ((app-arr (append-image (load-png "~/Pictures/img-2")
  ;;                                  (load-png "~/Pictures/img-3") (cdr res))))
  ;;       (destructuring-bind (height width  &rest rest)
  ;;           (array-dimensions app-arr)
  ;;         (save-png width height "~/Pictures/area.png" app-arr :grayscale)))))

  <<create_roll>>
#+END_SRC
**** Склеивание картинок

~аppend-image~
принимает 2 массива с изображениями, которые должны иметь одинаковую
ширину и кол-во байт на пиксель, точку, от которой будет производиться склейка,
и возвращает склеенный массив.

#+NAME: append_image
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defun append-image (image-up image-down y-point)
    (destructuring-bind (height-down width-down &optional colors-down)
        (array-dimensions image-down)
      ;; (destructuring-bind (height-up width-up &optional colors-up)
      ;;     (array-dimensions image-up)
      (let* ((new-height (+ height-down y-point))
             (new-dims (if (null colors-down)
                           (list new-height width-down)
                           (list new-height width-down colors-down)))
             (image-new (make-array new-dims :element-type '(unsigned-byte 8))))
        (destructuring-bind (height-new width-new &optional colors-new)
            (array-dimensions image-new)
          (dbg "~%  append-image: height-new ~A width-new ~A y-point ~A"
                  height-new width-new y-point))
        ;; макрос для прохода по блоку точек
        (macrolet ((cycle ((py px height width &optional &body newline)
                           &body body)
                     `(do ((qy ,py (incf qy)))
                          ((= qy ,height))
                        (do ((qx ,px (incf qx)))
                            ((= qx ,width))
                          ,@body)
                        ,@newline)))
          ;; копируем первую картинку в новый массив
          ;; от ее начала до точки склейки, или до ее конца,
          ;; смотря что случится раньше
          (if (null colors-down)  ;; TODO: тут надо проверять цвета первой картинки
              ;;(cycle (0 0 (min height-down y-point) width-down)
              (cycle (0 0 y-point width-down)
                     (setf (aref image-new qy qx)
                           (aref image-up qy qx)))
              ;; else
              (cycle (0 0 y-point width-down)
                     (do ((qz 0 (incf qz)))
                         ((= qz colors-down))
                       (setf (aref image-new qy qx qz)
                             (aref image-up qy qx qz)))))
          ;; копируем вторую картинку в новый массив
          ;; от ее начала до конца
          (if (null colors-down)
              (let ((new-y y-point))
                (cycle (0 0 height-down width-down (incf new-y))
                       (setf (aref image-new new-y qx)
                             (aref image-down qy qx))))
              ;; else
              (let ((new-y y-point))
                (cycle (0 0 height-down width-down (incf new-y))
                       (do ((rz 0 (incf rz)))
                           ((= rz colors-down))
                         (setf (aref image-new new-y qx rz)
                               (aref image-down qy qx rz)))))))
        image-new)))

  ;; (block test-append-image-fullcolor
  ;;   (let* ((arr1 (x-snapshot :x 0 :y 0 :width 755 :height 300))
  ;;          (arr2 (x-snapshot :x 100 :y 100 :width 755 :height 300))
  ;;          (array (append-image arr1 arr2 200)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array))))


  ;; (block test-append-image-grayscale
  ;;   (let* ((arr1 (binarization (x-snapshot :x 0 :y 0 :width 755 :height 600)))
  ;;          (arr2 (binarization (x-snapshot :x 0 :y 555 :width 755 :height 130)))
  ;;          (array (append-image arr1 arr2 600)))
  ;;     (destructuring-bind (height width  &rest rest)
  ;;         (array-dimensions array)
  ;;       (save-png width height "~/Pictures/result.png" array :grayscale))))
#+END_SRC

**** Create roll

Взаимодействует с очередью результатов. Вызывается после того, как была найдена
последняя картинка, а поток-поставщик и потоки-потребители - убиты.
Склейка происходит линейно: сначала склеиваем изображения 1 и 2, потом получившийся
рулон и изображение 3 и т.д. Пока не исчерпаем все изображения. Порядок
обработанных результатов, которые мы берем из очереди, очень важен, если его не
соблюдать, то склейка превратится в мусор.

Алгорим:
- взять первый результат из ~results-queue~
- склеить картинки (получили начало свитка)
- взять следующий результат. Посчитать смещение координаты y.
- склеить ~image-down~ текущего результата с рулоном
  (~image-up~ текущего результата нам не нужен, поскольку он повторяет самое нижнее
  изображение свитка)
- повторять, пока очередь результатов не станет пустой

~Высчитать смещение~
Зачем вообще высчитывать смещение?

Наши изображения собираются в такси и анализируются парами. К моменту вызова
~create-roll~  у нас уже есть все данные для склейки: проанализированные изображения
и ~y-points~, на которых надо изображения склеить.

Предположим, высота каждого изображения = 100
Мы берем первый таск в очереди и клеим изображения 1 и 2. Получаем начало рулона.
Предположим, изображения мы склеили в стык, и теперь высота нового массива = 200.
У нас уже есть готовый результат анализа для изображений 2 и 3, поэтому мы могли
бы просто приклеить изображение 3 к рулону. Но есть одна проблема.
Когда ~изображение 2~ не было частью рулона, самая верхняя его строка имела
координату ~y~ 0. После склейки все ~Y-координаты~ ~изображения 2~ сместились,
и теперь оно начинается в рулоне с ~y-point~ 99. Значит, нельзя уже приклеить
~изображение 3~ по старому результату. Иначе мы вклеим его где-то по середине
рулона. Нам нужно высчитать смещение и получить новую точку склйки.

Делаем мы это следующим образом.
Все изображения при скрининге имеют стандартную высоту, она заранее известна.
Мы можем высчитать, насколько далеко от конца изображения находится ~y-point~,
на котором должна была производиться склейка, а затем вычтем это расстояние из
высоты рулона, получив таким образом новый ~y-point~.

Возьмем уже описанный пример:
- изображения 1, 2 и 3 имеют высоту 100 пикселей
- после склейки изображения 1 и 2 высота рулона = 200
- берем результат анализа для изображения 2 и 3, предположим, ~y-point~ = 99
- узнаем, насколько далеко от конча изображения 2 находится y-point:
  высота изображения 2 - y-point = 100 - 99 = 1.Теперь мы знаем,
  что лучший результат анализа был получен за 1 ряд пикселей до конца.
- вычитаем из высоты рулона полученную величену: 200 - 1 = 199
- новая точка склейки = 199.

Этот алгоритм должен действивать для каждого этапа склейки.

#+NAME: create_roll
#+BEGIN_SRC lisp :noweb yes
  (defun create-roll (path own-cv results-queue-lock)
    (loop
       (bt:with-lock-held (results-queue-lock)
         ;; wait for access
         (bt:condition-wait own-cv results-queue-lock)
         (dbg "~% create roll is woke")
         ;; если все сработает верно, то управление в эту строку
         ;; попадет только 1 раз, поэтому не будет попытки удалить несуществующие потоки
         (stop-report-and-kill-producer "stop-report-andd-kill-producer: last image!")
         (kill-all-consumers "kill-all-consumers: last image!")
         (dbg "~% all threads are killed")
         ;; take first img-pair
         (let* ((cur-result (pop *results-queue*))
                (cur-y-point (result-y-point cur-result))
                (cur-image-up (result-image-up cur-result))
                (cur-image-down (result-image-down cur-result))
                ;; append it
                ;; не считаем смещение, потому что на первой склейке его просто нет
                (roll (append-image cur-image-up cur-image-down cur-y-point)))
           ;; do till end of result-queue
           (do ((i (length *results-queue*) (decf i)))
               (( = i 0))
             ;; take img-pair
             (setf cur-result (pop *results-queue*)
                   cur-image-down (result-image-down cur-result)
                   cur-y-point (result-y-point cur-result))
             ;; find height of roll (нам это нужно, чтоб считать смещение)
             (destructuring-bind (height-roll width-roll &optional colors-roll)
                 (array-dimensions roll)
               (destructuring-bind (height-up width-up &optional colors-up)
                   (array-dimensions (result-image-up cur-result))
                 ;; offset
                 ;; поскольку индексация в массивах начинается с 0, то от height
                 ;; мы отнимаем 1: если array-dimensions вернула значение 668 для height,
                 ;; это означает, что у нас 668 строк с индексацие от 0 до 667,
                 ;; а не от 1 до 668. Так мы избежим погрешности в 1 пиксель
                 (let* ((difference (- (- height-up 1) cur-y-point))
                        (new-y-point (- height-roll difference)))
                   (dbg "~% do: i ~A; height-roll ~A cur-y-point ~A new-y-point ~A"
                        i height-roll cur-y-point new-y-point)
                   (setf roll (append-image roll cur-image-down new-y-point))))))
           ;; save roll
           (destructuring-bind (height-roll width-roll &optional colors-roll)
               (array-dimensions roll)
             (if colors-roll
                 (progn
                   (save-png width-roll height-roll path roll)
                   (return-from create-roll t))
                 (progn
                   (dbg "~% all the end!")
                   (save-png width-roll height-roll path roll :grayscale)
                   (return-from create-roll t))))))))


#+END_SRC

**** The result

[COMMENT:gmm] Название структуры выбрано плохо, потому что при попытке
найти ее определение или созание мы будем постоянно натыкаться на
локальные переменные result в функциях.

Структура results включает в себя:
- % черных точек
- % белых точек
- y-point, на котором данный результат был получен
- image-up - массив изображения image-up
- image-down - массив изображения image-down

#+NAME: the_result
#+BEGIN_SRC lisp :noweb yes
  (in-package  #:cl-autogui)

  (defstruct result
    black
    white
    y-point
    image-up image-down)
#+END_SRC

* Экспорт

#+NAME: pc
#+BEGIN_SRC lisp :noweb yes :tangle pc.lisp

  <<libs>>
  <<defparams>>
  (in-package #:cl-autogui)
  <<the_task>>
  <<append_image>>

  <<pc_create_threads>>

  ;; теперь ты можешь собрать скрины онлайн
  (block producer-consumers-test
    (open-browser "/usr/bin/firefox" "https://spb.hh.ru/")
    (sleep 3)
    (create-threads 3))

  ;; (defun producer-test ()
  ;;   (bt:make-thread (lambda ()
  ;;                     (producer *cv-pc* *task-queue-lock* *task-queue* *outlock*))
  ;;                   :name "producer-thread")
  ;;   (loop
  ;;      (if (eql (length *task-queue*) 5)
  ;;          (progn
  ;;            (stop-report-and-kill-producer "stop-report-andd-kill-producer: last image!")
  ;;            (return-from producer-test t)))))


  ;; (block producer-test
  ;;   (open-browser "/usr/bin/firefox" "https://spb.hh.ru/")
  ;;   (sleep 8)
  ;;   (producer-test))

  ;; OUTPUT:
  ;; thread 'producer-thread' created
  ;; thread 'consumer0' created
  ;; thread 'consumer1' created
  ;; consumer-0 started
  ;; consumer-1 started consumer-1 started
  ;; consumer-0 reported: no task in queue; skip
  ;; consumer-1 woke up for (img-1 . img-2); 0 tasks left, 0 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-0 woke up for (img-2 . img-3); 0 tasks left, 1 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-1 woke up for (img-3 . img-4); 0 tasks left, 2 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-0 woke up for (img-4 . img-5); 0 tasks left, 3 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-1 woke up for (img-5 . img-6); 0 tasks left, 4 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-0 woke up for (img-6 . img-7); 0 tasks left, 5 processed
  ;; "ANALIZE-IMG-PAIR"
  ;; consumer-0 reported: task limit has been reached; stop
#+END_SRC

* Идеи

1. У каждой пары анализируемых изображений должен быть свой пулл результатов. Этот пул
   создается внутри потока. Туда записывается 2 изображения и результаты для них, вида
   ((черные точки. белые точки. y-point) изображение 1 изображение 2)
   На выходе поток сортирует результаты и возвращает наилучший результат в общий пул
   результатов вида ((черные точки . y-point) изображение 1 изображение 2)

_______________________________________________________________________________

2. Склейка
выполняет после получения результатов для всех тасков
получаем массив с подсписками.

склеить картинку
если длина results != 1, т.е мы не получили цнлый рулон картинку
(create-task)
~top~
results = tasks
очистить results
(setf results analysis)
записать полученные массивы в results
если длина results != 1, т.е мы не получили цнлый рулон картинку
~go top~
